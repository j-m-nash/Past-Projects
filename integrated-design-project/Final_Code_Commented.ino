#include <Wire.h>#include <Adafruit_MotorShield.h>Adafruit_MotorShield AFMS = Adafruit_MotorShield();Adafruit_DCMotor *Motorr = AFMS.getMotor(1);Adafruit_DCMotor *Motorl = AFMS.getMotor(2);Adafruit_DCMotor *Motorg = AFMS.getMotor(3);float c = 0.0; //ratio of the step, this controls how quickly the arduino cycles through the loop codeint state = 0;int oldstate;int v = 255;int velocityr ;int velocityl ;const int trigPin = 2;const int echoPin = 3;long duration;int distance;int minedist;int drivetime;int starttime;int hallsense = 0;int runstodo = 4;int flip = 0;int light = 0;int t = 0;int North = 7;int South = 6;int valNorth = 0;int valSouth = 0;const int amber =  12;const int red =  13;void setup(){  pinMode(trigPin, OUTPUT);  pinMode(echoPin, INPUT);  pinMode(amber, OUTPUT);  pinMode(red, OUTPUT);//  Serial.begin(9600);  used for debugging  AFMS.begin();}/*"directionX"The functions that convert forward negative velocities into backward positive*/int directionr(int velocityr) //right wheel{  if (velocityr > 0)  {    return FORWARD;  }  else  {    return BACKWARD;  }}int directionl(int velocityl) //left wheel{  if (velocityl < 0)  {    return FORWARD;  }  else  {    return BACKWARD;  }}int directiong(int velocityg) //grabber{  if (velocityg<0)  {    return FORWARD;  }  else  {    return BACKWARD;  }} /*"motion"The function that actually makes the robot drive*/void motion(int vr, int vl, int vg, int b){  if (starttime < int(c) && int(c) < starttime + b)  {    Motorr->run(directionr(vr));    Motorl->run(directionl(vl));    Motorg->run(directionl(vg));    Motorr->setSpeed(abs(vr));    Motorl->setSpeed(abs(vl));    Motorg->setSpeed(abs(vg));  }  starttime += b;}/*"The building blocks"Each of the following functions are the blocks used in the stateX() functions, which tell the robot which motors to run in which way,and when to change lights and state*/void forward(int b){  motion(v, v, 0, b);}void backward(int b){  motion(-v, -v, 0, b);}void turnr(int b){  motion(-v, v, 0, b);}void turnrs(int b){  motion(0, v, 0, b);}void turnl(int b){  motion(v, -v, 0, b);}void turnls(int b){  motion(0, -v, 0, b);}void nomotion(int b){  motion(0, 0, 0, b);}void grabber(int b){  motion(0, 0, 150, b);}void resetgrabber(int b){  motion(0, 0, -150, b);}void newstate(int a){  state = a;  c = 0.0;  if (a == 2)  {    runstodo -= 1; // way of tracking number of runs complete, for when to return home and how far to drive to red zone  }  if (runstodo == 0)  {    state = 9;  }}void changestate(int b){  if (starttime < int(c))  {    newstate(b);  }}void changevelocity(int b){  if (starttime == int(c))  {    v = b;  }}void changelight(int a){  if (starttime < int(c))  {    light = a;  }}/*"stateX"The various paths taken by the robot*/void state0() //time for placing baattery, grabber resets{  nomotion(1000);  resetgrabber(500);  changelight(3);  changestate(1);}void state1() // move forward and back{  backward(200);  forward(1050 + (4 - runstodo) * 50);  backward(1100 + (4 - runstodo) * 50);  changestate(2);}void state2() //go to the next path{  backward(100);  forward(150);  turnl(257);  forward(500);  turnr(245);  changestate(1);}void state3() //drive to the mine{  changelight(2);  forward(273);  turnls(500);  forward(drivetime);  changestate(4);}void state4() //collect mine and return to original path{  nomotion(250);  forward(200);  grabber(175);//  grabber(flip*100);  changelight(1);  backward(100);  backward(drivetime);  turnrs(440);  changestate(5);}void state5() //drive backward to the starting point of this path{  backward(minedist + 150);  changestate(6);}void state6() //drive to red zone{  forward(150);  turnl(258);  backward(500 * (4 - runstodo) + 500);  forward(2530);  grabber(175);  resetgrabber(150);  grabber(250);  resetgrabber(150);  grabber(250);  resetgrabber(150);  grabber(250);  changestate(7);}void state7() //drive back to start of run{  changelight(3);  backward(500 * runstodo + 175);  resetgrabber(600);  turnr(225);  backward(150);  changestate(1);}void state8() //Mine detected in front of robot{  changelight(2);  nomotion(250);  forward(300);  grabber(175);//  grabber(flip*100);  changelight(1);  backward(100);  changestate(5);}void state9() //once whole table has been searched, robot returns home{  backward(100);  forward(150);  turnl(250);  backward(2000);  forward(100);  turnr(250);  nomotion(1000000);}/* Failsafe states implemented for the monday competition:  void state10()  {  changelight(3);  backward(500*runstodo+150);  resetgrabber(250);  turnr(250);  backward(150);  forward(100);  nomotion(100000);  }  void state11()  {  nomotion(10000);  }  *//*"path"One of the main 3 functions in the code. Depending on the stateof the robot, one of the state functions is called to determinewhere the robot moves*/void path(){  starttime = 0;  if (state == 0)  {    state0();  }  else if (state == 1)  {    state1();  }  else if (state == 2)  {    state2();  }  else if (state == 3)  {    state3();  }  else if (state == 4)  {    state4();  }  else if (state == 5)  {    state5();  }  else if (state == 6)  {    state6();  }  else if (state == 7)  {    state7();  }  else if (state == 8)  {    state8();  }  else if (state == 9)  {    state9();  }  /*  else if (state==10)    {      state10();    }    else if (state==11)    {      state11();    } */}/*"lights"One of the main 3 functions in the code. This causes the lights to flashat the correct frequency (also accounting for discrpeancies caused in the timer by the running of the sensor)*/void lights(){  if (state == 1)  {    t = 80;  }  else if (state == 5)  {    t = 80;  }  else  {    t = 160;  }  if (light == 0)  {    digitalWrite(amber, LOW);    digitalWrite(red, LOW);  }  if (light == 1 && (int(c) % t) < 40)  {    digitalWrite(amber, LOW);    digitalWrite(red, HIGH);  }  if (light == 1 && (int(c) % t) > 40)  {    digitalWrite(amber, LOW);    digitalWrite(red, LOW);  }  if (light == 2)  {    digitalWrite(amber, HIGH);    digitalWrite(red, LOW);  }  if (light == 3 && (int(c) % t) < 40)  {    digitalWrite(amber, HIGH);    digitalWrite(red, LOW);  }  if (light == 3 && (int(c) % t) > 40)  {    digitalWrite(amber, LOW);    digitalWrite(red, LOW);  }}/*"sense"The funciton that runs the ultrasonic sensor*/void sense(){  digitalWrite(trigPin, LOW);  delayMicroseconds(2);  digitalWrite(trigPin, HIGH);  delayMicroseconds(10);  digitalWrite(trigPin, LOW);  duration = pulseIn(echoPin, HIGH);  distance = duration * 0.034 / 2;}/*"sensor"One of 3 main functions in the code. This looks at all the sensor inputs and determines if any should result in a change of state for the robot.*/void sensor(){  if (state == 1)  {    sense();        //if mine detected to the side:    if (distance < 50 && c > 250 && c < (1050 + (4 - runstodo) * 50) + 200)    {      drivetime = 10 * distance;      minedist = int(c);      newstate(3);    }  }  if (state == 5)  {    sense();  }  valNorth = digitalRead(North);  valSouth = digitalRead(South);  if (valNorth == 0 && valSouth == 0)  {    hallsense = 0;  }  else  {    hallsense = 1;  }  //after mine detected to side, robot has reached mine:  if (state == 3 && hallsense == 1 && int(c) < 80)   {    drivetime = int(c) - 350;    newstate(4);    /*     if (valNorth == 1)    {      flip = 0;    }    else    {      flip = 1;    }    */      }  //mine detected in front:  if (state == 1 && hallsense == 1 && int(c) < 800 + (4 - runstodo) * 50)   {    minedist = int(c);    newstate(8);    /*     if (valNorth == 1)    {      flip = 0;    }    else    {      flip = 1;    }    */  }}/*"loop"The main loop of the code: the arduino constantly loops through these 3 functions, which determine the robot's path (path()), whether it should react to externalinputs (sensor()), and which lights should be flashing (lights()) */void loop(){  for (c = 0.0; c = c + 1.5;)  {    path();    sensor();    lights();  }}